Практическое задание #3.
Дедлайн: 11.12

Нужно реализовать конкуррентное external бинарное дерево без балансировки.

Что для этого сделать:
1. Написать конкуррентное бинарное дерево.
2. Придумать и реализовать способ верификации корректности дерева, это душная часть, но важная.
3. Посчитать число ops в секунду при следующей нагрузке:
  K = {1,...,10^5}
  prepopulate() -> взять каждый элемент с вероятностью 1/2

  Каждый процесс:
  while time < 5s:
    key = random(K)
    p = random()
    switch:
        p < x: insert(key)
        x <= p < 2x: remove(key)
        2x <= p <= 1: contains(key)

Как итог нужно построить табличку с пропускными способностями на 1,2,3,4 процесса и на x=0, 0.1, 0.5.

Результат Вы посылаете письмо с названием "CW3. <ФИО>". Содержит:
  - Ссылки на код.
  - Верификация алгоритма и описание метода.
  - Табличка. Ожидаю ускорение в 3 раза на 4 процессах.


  g++ -O2 -I./parlaylib/include/ hw_3.cpp -o hw_3.out

  ./hw_3.out

[root@9f85b60c77b1 mpp]# ./hw_3.out 
Время выполнения для моей реализации: 16.8017 секунд
Время выполнения для set: 12.9543 секунд